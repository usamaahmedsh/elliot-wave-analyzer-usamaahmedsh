# Pipeline configuration optimized for Mac M4 Pro
# Tuned for maximum pattern detection with efficient resource usage

# AUTO DEVICE DETECTION (recommended)
# Set to true to automatically detect hardware and optimize settings
# - Detects CUDA GPUs (HPC/NVIDIA)
# - Detects Apple Silicon GPU (Mac M1/M2/M3/M4)
# - Falls back to optimized CPU settings
# When enabled, automatically sets: processes, cpu_batch_size, concurrency
auto_detect_device: true

days: 5475  # 15 years of historical data
slide_weeks: 2  # Larger steps for faster scanning (trade-off: might miss some patterns)
min_weeks: 8  # Minimum 2 months to catch meaningful patterns
max_weeks: 104  # 2 years max window to capture longer Elliott Wave cycles
up_to: 8  # Higher complexity = more pattern variations (5=simple, 8=moderate, 12=complex)
grow_weeks: 1
top_n: 20  # Keep more top patterns per window (increased from 10)
delay: 0.5

# These will be AUTO-DETECTED if auto_detect_device=true
# Only used if auto_detect_device=false
processes: 10  # Will use 10 workers (auto-detected for M4 Pro)
cpu_batch_size: 1024  # Larger batches for better vectorization
concurrency: 12  # Network fetch parallelism

max_combinations: 500000  # Increased from 200k to explore more candidates
out_dir: output

# Pattern scanning mode: 'all' scans impulsive + corrective, 'impulses' scans only impulsive waves
scan_pattern_types: all  # Scan both impulsive and corrective patterns

# Multi-start search: try multiple pivot points (local extrema) as wave starts
# Set to true to enable, false for single-start (faster)
enable_multi_start: true  # Enable to find patterns at different starting points
max_start_points: 8  # Try more starting points for better coverage (increased from 5)

# Overlapping windows: set overlap_ratio > 0 to create overlapping time windows
# overlap_ratio=0.5 means 50% overlap (catches patterns spanning boundaries)
window_overlap_ratio: 0.5  # 50% overlap to catch patterns at window boundaries

# Enable shared memory for quick testing (workers will map lows/highs/dates)
use_shared_memory: true

# For quick profiling runs, lower the window budget so the run is fast. Set to 50 for quick test.
max_windows: 500  # Scan 500 windows per symbol for comprehensive coverage

# Image saving - ENABLED for manual review
save_images: true  # Save pattern visualizations
save_images_top_n: 5  # Save top 5 patterns per symbol

# Inline pattern analysis - show quality statistics during pipeline run
analyze_patterns: false  # Set to true to see score distributions per symbol in real-time
chunk_size: 0
min_volatility: 0.0
skip_flat_windows: false
profile: true

# Pre-score knobs (cheap vectorized features to prune windows)
pre_score_top_k: 0
pre_score_threshold: 0.0
# weights: volatility, range, extrema_count, abs(slope)
pre_score_weights: [0.4, 0.3, 0.2, 0.1]

# Sweep knobs (optional) â€” used by `tools/sweep_cpu_batch.py` if present.
# Edit these lists to control which values are tried by the sweep driver.
cpu_batch_sizes: [128, 256, 512, 1024]
cpu_top_k_values: [16, 32, 64, 128]

# Suggested profiles (examples):
# - Local Apple Silicon (M4 Pro):
#   processes: 6           # use physical cores or cores-1
#   concurrency: 12        # network fetch parallelism
#   chunk_size: 16         # tune for your workload
#   max_windows: 500       # cap per-symbol windows for exploratory runs
#   save_images: false
#
# - HPC (A100 + 32 threads):
#   processes: 31          # use number of CPU workers (threads) you want to utilize
#   concurrency: 64        # many async fetchers / HF readers
#   chunk_size: 64         # larger chunk size reduces IPC overhead on high-core machines
#   max_windows: 2000      # increase scan budget if you want exhaustive search
#   save_images: false     # keep off for bulk runs; enable only top_n small

